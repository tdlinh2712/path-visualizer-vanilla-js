const M="wall";class y{constructor(t,e,i){this.board=document.getElementById(t),this.rows=e,this.cols=i,this.currentDelay=0,this.start_cell=null,this.target_cell=null,this.isMouseDown=!1,this.addWallEventListeners(),this.visitedNodes=[],this.foundPath=[],this.stat={visited_cells:0,path_length:0,elapsedTime:0}}initializeElements(){for(let t=0;t<this.rows;t++){let e=this.board.insertRow(t);for(let i=0;i<this.cols;i++)e.insertCell(i)}}resetDelayTime(){this.currentDelay=0}resetBoard(){this.clearBoard(),this.clearWalls(),this.resetDelayTime(),this.resetStartAndTarget(),this.resetStat()}clearBoard(){this.visitedNodes.forEach((t,e)=>{this.board.rows[t.row].cells[t.col].classList.remove("visitedNode")}),this.foundPath.forEach((t,e)=>{this.board.rows[t.row].cells[t.col].classList.remove("shortestPath")}),this.resetDelayTime()}fillWithWalls(){this.board.classList.add("fill-walls")}clearWalls(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++)this.board.rows[t].cells[e].classList.remove(M)}resetStartAndTarget(){this.start_cell!=null&&this.start_cell.dom.classList.remove("start-cell"),this.target_cell!=null&&this.target_cell.dom.classList.remove("target-cell"),this.start_cell=null,this.target_cell=null}resetStat(){this.stat={visited_cells:0,path_length:0,elapsedTime:0}}visualizeNewVisitedCell(t){if(this.containsClass(t,"visitedNode")||this.isStart(t)||this.isTarget(t))return;this.stat.visited_cells+=1;const e=this.board.rows[t.row].cells[t.col];e.className="visitedNode"}visualizeFoundPath(t){let e=Math.min(t.length,this.foundPath.length);for(let i=1;i<Math.min(t.length,this.foundPath.length);i++){const s=t[i],o=this.foundPath[i];if(s.row!=o.row||s.col!=o.col){e=i;break}}this.foundPath.slice(e).forEach((i,s)=>{const o=this.board.rows[i.row].cells[i.col];o.className="visitedNode"}),t.slice(e).forEach((i,s)=>{if(this.isStart(i)||this.isTarget(i))return;const o=this.board.rows[i.row].cells[i.col];o.className="shortestPath"}),this.foundPath=t,this.stat.path_length=this.foundPath.length}displayStat(){const t=document.getElementById("stat");t.innerHTML=`
            <div class="stat-value">Visited Nodes: ${this.stat.visited_cells}</div>
            <div class="stat-value">Path Length: ${this.stat.path_length}</div>
            <div class="stat-value">Time Elapsed: ${this.stat.elapsedTime}s</div>
        `}visualizePathFindingAlgorithm(t){this.resetStat(),this.foundPath=[];const e=Date.now(),i=setInterval(()=>{this.stat.elapsedTime=(Date.now()-e)/1e3;const s=t.next();if(s.done){clearInterval(i);const{visited_nodes:r,found_path:n}=s.value;this.visitedNodes=r,this.visualizeFoundPath(n),this.displayStat();return}const[o,l]=s.value;this.visualizeNewVisitedCell(o),this.visualizeFoundPath(l),this.displayStat()},(document.getElementById("speed-range").max-document.getElementById("speed-range").value)*5)}valid_cell(t){return!(t.row<0||t.col<0||t.row>=this.rows||t.col>=this.cols)}getRandomCell(){let t=Math.floor(Math.random()*this.rows),e=Math.floor(Math.random()*this.cols);return{row:t,col:e}}getCell(t,e){return{dom:this.board.rows[t].cells[e],row:t,col:e}}generateStartAndTarget(){let t=null;do t=this.getRandomCell();while(this.isWall(this.getCell(t.row,t.col)));let e=null;do e=this.getRandomCell();while(e.row===t.row&&e.col===t.col||this.isWall(this.getCell(e.row,e.col)));this.setStartAndTarget(t,e)}setStartAndTarget(t,e){this.resetStartAndTarget(),this.start_cell=t,this.start_cell.dom=this.board.rows[t.row].cells[t.col],this.start_cell.dom.classList.add("start-cell"),this.target_cell=e,this.target_cell.dom=this.board.rows[e.row].cells[e.col],this.target_cell.dom.classList.add("target-cell")}addWallEventListeners(){this.board.addEventListener("dragstart",t=>t.preventDefault()),this.board.addEventListener("mousedown",t=>{t.preventDefault(),this.isMouseDown=!0,t.target.tagName==="TD"&&this.toggleWall(t.target)}),this.board.addEventListener("mouseover",t=>{this.isMouseDown&&t.target.tagName==="TD"&&this.toggleWall(t.target)}),window.addEventListener("mouseup",()=>{this.isMouseDown=!1})}resetToWalls(){this.clearBoard(),this.resetDelayTime(),this.resetStartAndTarget();const t=document.createDocumentFragment();for(let e=0;e<this.rows;e++){const i=document.createElement("tr");for(let s=0;s<this.cols;s++){const o=document.createElement("td");o.classList.add("wall"),i.appendChild(o)}t.appendChild(i)}this.board.innerHTML="",this.board.appendChild(t)}toggleWall(t){const e=t.parentNode.rowIndex,i=t.cellIndex;this.start_cell&&e===this.start_cell.row&&i===this.start_cell.col||this.target_cell&&e===this.target_cell.row&&i===this.target_cell.col||t.classList.add(M)}untoggleWall(t){t.classList.remove(M)}isWall(t){return this.board.rows[t.row].cells[t.col].classList.contains(M)}isTarget(t){return t.row===this.target_cell.row&&t.col===this.target_cell.col}isStart(t){return t.row===this.start_cell.row&&t.col===this.start_cell.col}containsClass(t,e){return this.board.rows[t.row].cells[t.col].classList.contains(e)}}class T{constructor(){this.values=[]}enqueue(t,e){let i=!1;for(let s=0;s<this.values.length;s++)if(this.values[s].priority>e){this.values.splice(s,0,{node:t,priority:e}),i=!0;return}i||this.values.push({node:t,priority:e})}dequeue(){return this.values.shift()}size(){return this.values.length}}const g=(c,t,e)=>!t.valid_cell(c)||t.isWall(c)||e.find(i=>i.row===c.row&&i.col===c.col),_=(c,t)=>c.row===t.row&&c.col===t.col,B=(c,t)=>Math.abs(c.row-t.row)+Math.abs(c.col-t.col),p=Object.freeze({BFS:"BFS",DFS:"DFS",DIJIKSTRA:"Dijikstra",A_STAR:"A*"}),h=[[0,1],[1,0],[0,-1],[-1,0]];class f{constructor(){this.supported_algorithms=p,this.current_algorithm=p.BFS,this.selector_dom=null}initializeAlgorithmSelector(t){this.selector_dom=t;for(var[e,i]of Object.entries(this.supported_algorithms)){var s=document.createElement("option");s.value=i,s.innerHTML=i,t.appendChild(s)}t.value=this.current_algorithm}setAlgorithm(t){this.current_algorithm=t}findPath(t,e,i){switch(this.current_algorithm){case p.BFS:return f.BFS(t,e,i);case p.DFS:return f.DFS(t,e,i);case p.DIJIKSTRA:return f.Dijikstra(t,e,i);case p.A_STAR:return f.AStar(t,e,i);default:return console.log("Unsupported option ",this.current_algorithm),{visited_nodes:[],found_path:[]}}}static*BFS(t,e,i){let s=[],o=[];for(o.push({...e,prev:[e]}),s.push(e),yield[e,[]];o.length>0;){const l=o.shift();for(let r=0;r<h.length;r++){const n={row:l.row+h[r][0],col:l.col+h[r][1]};if(g(n,t,s))continue;s.push(n);const a=[...l.prev,n];if(yield[n,a],_(n,i))return{visited_nodes:s,found_path:a};o.push({...n,prev:a})}}return{visited_nodes:s,found_path:[]}}static*DFS(t,e,i){let s=[],o=[{...e,found_path:[e]}];for(;o.length>0;){const l=o.at(-1);s.push(l),o.pop(),yield[l,l.found_path];for(let r=0;r<h.length;r++){const n={row:l.row+h[r][0],col:l.col+h[r][1]};if(!g(n,t,l.found_path)){if(_(n,i))return{visited_nodes:s,found_path:[...l.found_path,n]};o.push({...n,found_path:[...l.found_path,n]})}}}return{visited_nodes:s,found_path:[]}}static*DFSImpl(t,e,i,s){if(s.push(e),_(e,i))return yield[e,[e]],{visited_nodes:s,found_path:[e]};for(let o=0;o<h.length;o++){const l={row:e.row+h[o][0],col:e.col+h[o][1]};if(g(l,t,s))continue;const{found_path:r}=f.DFSImpl(t,l,i,s);if(r.length>0)return yield[e,[e,...r]],{visited_nodes:s,found_path:[e,...r]}}return{visited_nodes:s,found_path:[]}}static*Dijikstra(t,e,i){let s=[],o=new T;for(o.enqueue({...e,path:[e]},0);o.size()>0;){const{node:l,priority:r}=o.dequeue();if(_(l,i))return{visited_nodes:s,found_path:l.path};if(!g(l,t,s)){s.push(l),yield[l,l.path];for(let n=0;n<h.length;n++){const a={row:l.row+h[n][0],col:l.col+h[n][1]};g(a,t,s)||o.enqueue({...a,path:[...l.path,a]},r+1)}}}return{visited_nodes:s,found_path:[]}}static*AStar(t,e,i){let s=[],o=new T;for(o.enqueue({...e,path:[e],distance:0,heuristic:0},0);o.size()>0;){const{node:l}=o.dequeue();if(_(l,i))return{visited_nodes:s,found_path:l.path};if(!g(l,t,s)){s.push(l),yield[l,l.path];for(let r=0;r<h.length;r++){const n={row:l.row+h[r][0],col:l.col+h[r][1]};if(!g(n,t,s)){let a={...n,path:[...l.path,n],distance:l.distance+1,heuristic:B(n,i)};o.enqueue(a,a.distance+a.heuristic)}}}}return{visited_nodes:s,found_path:[]}}}const w={PRIM:"Prim",KRUSKAL:"Kruskal",RECURSIVE_BACKTRACKING:"Recursive Backtracking",ELLER:"Eller"},S=[[0,1],[1,0],[0,-1],[-1,0]],E={HORIZONTAL:[0,1],VERTICAL:[1,0]};Object.freeze(w);class k{constructor(){this.currentAlgorithm=w.PRIM}setAlgorithm(t){this.currentAlgorithm=t}generateMaze(t){switch(this.initializeMaze(t),this.currentAlgorithm){case w.PRIM:this.primMaze(t);break;case w.KRUSKAL:this.kruskalMaze(t);break;case w.RECURSIVE_BACKTRACKING:this.recursiveBacktrackingMaze(t);break;case w.ELLER:this.ellersMaze(t);break;default:console.error("Unknown maze generation algorithm");return}setTimeout(()=>{let e={row:0,col:0},i={row:t.rows-1,col:t.cols-1};t.setStartAndTarget(e,i)},this.currentDelay)}animateMaze(t,e){setTimeout(()=>{e.forEach(i=>{i.dom&&(i.dom.classList.add("maze-reveal"),t.untoggleWall(i.dom))})},this.currentDelay),this.currentDelay+=parseInt(document.getElementById("speed-range").max-document.getElementById("speed-range").value)}initializeMaze(t){this.currentDelay=2e3,t.resetToWalls()}isValidFrontier(t,e){return t.valid_cell(e)&&t.isWall(e)}replaceFlag(t,e,i){for(let s=0;s<t.length;s+=2)for(let o=0;o<t[s].length;o+=2)t[s][o]===e&&(t[s][o]=i);return t}initializeMazeSelector(t){const e=Object.values(w);t.innerHTML="",e.forEach(i=>{const s=document.createElement("option");s.value=i,s.text=`${i}'s Algorithm`,t.appendChild(s)})}primMaze(t){const e=Math.floor(Math.random()*t.rows/2)*2,i=Math.floor(Math.random()*t.cols/2)*2,s=t.getCell(e,i);this.animateMaze(t,[s]);const o=new Set;o.add(`${s.row},${s.col}`);const l=S.map(r=>({row:s.row+r[0]*2,col:s.col+r[1]*2,direction:r})).filter(r=>this.isValidFrontier(t,r,[]));for(;l.length>0;){const r=Math.floor(Math.random()*l.length),n=l[r];l.splice(r,1);const a=`${n.row},${n.col}`;if(!o.has(a)&&(o.add(a),this.isValidFrontier(t,n))){const m={row:n.row-n.direction[0],col:n.col-n.direction[1]};m.dom=t.getCell(m.row,m.col).dom,n.dom=t.getCell(n.row,n.col).dom,this.animateMaze(t,[n,m]),S.forEach(d=>{const v={row:n.row+d[0]*2,col:n.col+d[1]*2,direction:d};l.push(v)})}}}kruskalMaze(t){const e=[];let i=1,s=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(0));for(let o=0;o<t.rows;o+=2)for(let l=0;l<t.cols;l+=2)l+E.HORIZONTAL[1]*2<t.cols&&e.push({row:o,col:l,direction:E.HORIZONTAL}),o+E.VERTICAL[0]*2<t.rows&&e.push({row:o,col:l,direction:E.VERTICAL}),s[o][l]=i,i++;for(;e.length>0;){const o=Math.floor(Math.random()*e.length),l=e[o],r={row:l.row+l.direction[0]*2,col:l.col+l.direction[1]*2};if(s[r.row][r.col]!==s[l.row][l.col]){const n=s[r.row][r.col],a=s[l.row][l.col];s=this.replaceFlag(s,n,a);const m=[];for(let d=l.row;d<=r.row;d++)for(let v=l.col;v<=r.col;v++){const R=t.getCell(d,v);m.push(R)}this.animateMaze(t,m)}e.splice(o,1)}}recursiveBacktrackingMaze(t){let e=t.getCell(0,0),i=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(!1));this.recursiveBacktrackingImpl(t,e,i)}recursiveBacktrackingImpl(t,e,i){i[e.row][e.col]=!0,this.animateMaze(t,[t.getCell(e.row,e.col)]);const s=S.map(o=>({row:e.row+o[0]*2,col:e.col+o[1]*2,direction:o})).filter(o=>t.valid_cell(o)&&!i[o.row][o.col]);for(;s.length>0;){const o=Math.floor(Math.random()*s.length),l=s[o];s.splice(o,1),!i[l.row][l.col]&&(this.animateMaze(t,[t.getCell(l.row-l.direction[0],l.col-l.direction[1])]),this.recursiveBacktrackingImpl(t,l,i))}}ellersMaze(t){let e=new Uint16Array(t.cols);for(let s=0;s<t.cols;s++)e[s]=s;let i=new Map;e.forEach(s=>{s%2!=1&&i.set(s,[s])});for(let s=0;s<t.rows;s+=2){let o=s+2>=t.rows;for(let r=0;r<t.cols-2;r+=2)e[r]!=e[r+2]&&(o||Math.floor(Math.random()*2))&&(this.mergeSetInRow(e,e[r],e[r+2],i),this.animateMaze(t,[t.getCell(s,r),t.getCell(s,r+1),t.getCell(s,r+2)]));if(o)continue;const l=new Uint16Array(t.cols);for(let r=0;r<t.cols;r++)l[r]=r+(s+2)*t.cols;i.forEach((r,n)=>{for(let a=0;a<r.length*.6;a++){let m=Math.floor(Math.random()*r.length),d=r[m];l[d]=n,this.animateMaze(t,[t.getCell(s,d),t.getCell(s+1,d),t.getCell(s+2,d)])}}),i=new Map,l.forEach((r,n)=>{if(n%2==1)return;const a=i.get(r);a?a.push(n):i.set(r,[n])}),e=l}}mergeSetInRow(t,e,i,s){s.set(e,[...s.get(e),...s.get(i)]),s.delete(i);for(let o=0;o<t.length;o+=2)t[o]==i&&(t[o]=e)}}const C=25,D=300;function P(){const c=window.innerWidth-D,t=window.innerHeight-D,e=Math.floor(c/C/2)*2+1;return{rows:Math.floor(t/C/2)*2+1,cols:e}}const{rows:N,cols:F}=P(),u=new y("board",N,F),L=new f;u.initializeElements();u.resetBoard();u.generateStartAndTarget();const W=document.getElementById("start-btn"),x=document.getElementById("reset-btn"),I=document.getElementById("algorithm-btn");L.initializeAlgorithmSelector(I);I.addEventListener("change",()=>{L.setAlgorithm(I.value)});x.addEventListener("click",()=>{u.resetBoard(),u.generateStartAndTarget()});W.addEventListener("click",()=>{u.clearBoard();const c=L.findPath(u,u.start_cell,u.target_cell);u.visualizePathFindingAlgorithm(c)});const z=new k,A=document.getElementById("maze-btn"),O=document.getElementById("generate-maze-btn");z.initializeMazeSelector(A);A.addEventListener("change",()=>{z.setAlgorithm(A.value)});O.addEventListener("click",()=>{z.generateMaze(u)});
