(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const l of s)if(l.type==="childList")for(const i of l.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function e(s){const l={};return s.integrity&&(l.integrity=s.integrity),s.referrerPolicy&&(l.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?l.credentials="include":s.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(s){if(s.ep)return;s.ep=!0;const l=e(s);fetch(s.href,l)}})();const p="wall";class y{constructor(t,e,r){this.board=document.getElementById(t),this.rows=e,this.cols=r,this.currentDelay=0,this.start_cell=null,this.target_cell=null,this.isMouseDown=!1,this.addWallEventListeners()}initializeElements(){for(let t=0;t<this.rows;t++){let e=this.board.insertRow(t);for(let r=0;r<this.cols;r++)e.insertCell(r)}}resetDelayTime(){this.currentDelay=0}resetBoard(){this.clearBoard(),this.clearWalls(),this.resetDelayTime(),this.resetStartAndTarget()}clearBoard(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++){const r=this.board.rows[t].cells[e];r.classList.remove("visitedNode"),r.classList.remove("shortestPath")}this.resetDelayTime()}fillWithWalls(){this.board.classList.add("fill-walls")}clearWalls(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++)this.board.rows[t].cells[e].classList.remove(p)}resetStartAndTarget(){this.start_cell!=null&&this.start_cell.dom.classList.remove("start-cell"),this.target_cell!=null&&this.target_cell.dom.classList.remove("target-cell"),this.start_cell=null,this.target_cell=null}visualizeVisitedNodes(t){t.forEach((e,r)=>{if(this.isStart(e)||this.isTarget(e))return;const s=this.board.rows[e.row].cells[e.col];setTimeout(()=>{s.className="visitedNode"},r*2+this.currentDelay)}),this.currentDelay+=t.length*2}visualizeFoundPath(t){t.forEach((e,r)=>{if(this.isStart(e)||this.isTarget(e))return;const s=this.board.rows[e.row].cells[e.col];setTimeout(()=>{s.className="shortestPath"},r*5+this.currentDelay)}),this.currentDelay+=t.length*5}valid_cell(t){return!(t.row<0||t.col<0||t.row>=this.rows||t.col>=this.cols)}getRandomCell(){let t=Math.floor(Math.random()*this.rows),e=Math.floor(Math.random()*this.cols);return{row:t,col:e}}getCell(t,e){return{dom:this.board.rows[t].cells[e],row:t,col:e}}generateStartAndTarget(){let t=null;do t=this.getRandomCell();while(this.isWall(this.getCell(t.row,t.col)));let e=null;do e=this.getRandomCell();while(e.row===t.row&&e.col===t.col||this.isWall(this.getCell(e.row,e.col)));this.setStartAndTarget(t,e)}setStartAndTarget(t,e){this.resetStartAndTarget(),this.start_cell=t,this.start_cell.dom=this.board.rows[t.row].cells[t.col],this.start_cell.dom.classList.add("start-cell"),this.target_cell=e,this.target_cell.dom=this.board.rows[e.row].cells[e.col],this.target_cell.dom.classList.add("target-cell")}addWallEventListeners(){this.board.addEventListener("dragstart",t=>t.preventDefault()),this.board.addEventListener("mousedown",t=>{t.preventDefault(),this.isMouseDown=!0,t.target.tagName==="TD"&&this.toggleWall(t.target)}),this.board.addEventListener("mouseover",t=>{this.isMouseDown&&t.target.tagName==="TD"&&this.toggleWall(t.target)}),window.addEventListener("mouseup",()=>{this.isMouseDown=!1})}toggleWall(t){const e=t.parentNode.rowIndex,r=t.cellIndex;this.start_cell&&e===this.start_cell.row&&r===this.start_cell.col||this.target_cell&&e===this.target_cell.row&&r===this.target_cell.col||t.classList.add(p)}untoggleWall(t){t.classList.remove(p)}isWall(t){return this.board.rows[t.row].cells[t.col].classList.contains(p)}isTarget(t){return t.row===this.target_cell.row&&t.col===this.target_cell.col}isStart(t){return t.row===this.start_cell.row&&t.col===this.start_cell.col}}class T{constructor(){this.values=[]}enqueue(t,e){let r=!1;for(let s=0;s<this.values.length;s++)if(this.values[s].priority>e){this.values.splice(s,0,{node:t,priority:e}),r=!0;return}r||this.values.push({node:t,priority:e})}dequeue(){return this.values.shift()}size(){return this.values.length}}const w=(c,t,e)=>!t.valid_cell(c)||t.isWall(c)||e.find(r=>r.row===c.row&&r.col===c.col),v=(c,t)=>c.row===t.row&&c.col===t.col,B=(c,t)=>Math.abs(c.row-t.row)+Math.abs(c.col-t.col),m=Object.freeze({BFS:"BFS",DFS:"DFS",DIJIKSTRA:"Dijikstra",A_STAR:"A*"}),h=[[0,1],[1,0],[0,-1],[-1,0]];class f{constructor(){this.supported_algorithms=m,this.current_algorithm=m.BFS,this.selector_dom=null}initializeAlgorithmSelector(t){this.selector_dom=t;for(var[e,r]of Object.entries(this.supported_algorithms)){var s=document.createElement("option");s.value=r,s.innerHTML=r,t.appendChild(s)}t.value=this.current_algorithm}setAlgorithm(t){this.current_algorithm=t}findPath(t,e,r){switch(this.current_algorithm){case m.BFS:return f.BFS(t,e,r);case m.DFS:return f.DFS(t,e,r);case m.DIJIKSTRA:return f.Dijikstra(t,e,r);case m.A_STAR:return f.AStar(t,e,r);default:return console.log("Unsupported option ",this.current_algorithm),{visited_nodes:[],found_path:[]}}}static BFS(t,e,r){let s=[],l=[];for(l.push({...e,prev:[e]}),s.push(e);l.length>0;){const i=l.shift();for(let o=0;o<h.length;o++){const n={row:i.row+h[o][0],col:i.col+h[o][1]};if(w(n,t,s))continue;s.push(n);const a=[...i.prev,n];if(v(n,r))return{visited_nodes:s,found_path:a};l.push({...n,prev:a})}}return{visited_nodes:s,found_path:[]}}static DFS(t,e,r){let s=[];return f.DFSImpl(t,e,r,s)}static DFSImpl(t,e,r,s){if(s.push(e),v(e,r))return{visited_nodes:s,found_path:[e]};for(let l=0;l<h.length;l++){const i={row:e.row+h[l][0],col:e.col+h[l][1]};if(w(i,t,s))continue;const{found_path:o}=f.DFSImpl(t,i,r,s);if(o.length>0)return{visited_nodes:s,found_path:[e,...o]}}return{visited_nodes:s,found_path:[]}}static Dijikstra(t,e,r){let s=[],l=new T;for(l.enqueue({...e,path:[e]},0);l.size()>0;){const{node:i,priority:o}=l.dequeue();if(v(i,r))return{visited_nodes:s,found_path:i.path};if(!w(i,t,s)){s.push(i);for(let n=0;n<h.length;n++){const a={row:i.row+h[n][0],col:i.col+h[n][1]};w(a,t,s)||l.enqueue({...a,path:[...i.path,a]},o+1)}}}return{visited_nodes:s,found_path:[]}}static AStar(t,e,r){let s=[],l=new T;for(l.enqueue({...e,path:[e],distance:0,heuristic:0},0);l.size()>0;){const{node:i}=l.dequeue();if(v(i,r))return{visited_nodes:s,found_path:i.path};if(!w(i,t,s)){s.push(i);for(let o=0;o<h.length;o++){const n={row:i.row+h[o][0],col:i.col+h[o][1]};if(!w(n,t,s)){let a={...n,path:[...i.path,n],distance:i.distance+1,heuristic:B(n,r)};l.enqueue(a,a.distance+a.heuristic)}}}}return{visited_nodes:s,found_path:[]}}}const g={PRIM:"Prim",KRUSKAL:"Kruskal",RECURSIVE_BACKTRACKING:"Recursive Backtracking",ELLER:"Eller"},L=[[0,1],[1,0],[0,-1],[-1,0]],_={HORIZONTAL:[0,1],VERTICAL:[1,0]};Object.freeze(g);class k{constructor(){this.currentAlgorithm=g.PRIM}setAlgorithm(t){this.currentAlgorithm=t}generateMaze(t){switch(this.initializeMaze(t),this.currentAlgorithm){case g.PRIM:this.primMaze(t);break;case g.KRUSKAL:this.kruskalMaze(t);break;case g.RECURSIVE_BACKTRACKING:this.recursiveBacktrackingMaze(t);break;case g.ELLER:this.ellersMaze(t);break;default:console.error("Unknown maze generation algorithm");return}setTimeout(()=>{let e={row:0,col:0},r={row:t.rows-1,col:t.cols-1};t.setStartAndTarget(e,r)},this.currentDelay)}animateMaze(t,e){setTimeout(()=>{e.forEach(r=>{r.dom&&(r.dom.classList.add("maze-reveal"),t.untoggleWall(r.dom))})},this.currentDelay),this.currentDelay+=10}initializeMaze(t){this.currentDelay=0,t.resetBoard();for(let e=0;e<t.rows;e++)for(let r=0;r<t.cols;r++)t.toggleWall(t.getCell(e,r).dom)}isValidFrontier(t,e){return t.valid_cell(e)&&t.isWall(e)}replaceFlag(t,e,r){for(let s=0;s<t.length;s+=2)for(let l=0;l<t[s].length;l+=2)t[s][l]===e&&(t[s][l]=r);return t}initializeMazeSelector(t){const e=Object.values(g);t.innerHTML="",e.forEach(r=>{const s=document.createElement("option");s.value=r,s.text=`${r}'s Algorithm`,t.appendChild(s)})}primMaze(t){const e=t.getCell(0,0);this.animateMaze(t,[e]);const r=new Set;r.add(`${e.row},${e.col}`);const s=L.map(l=>({row:e.row+l[0]*2,col:e.col+l[1]*2,direction:l})).filter(l=>this.isValidFrontier(t,l,[]));for(;s.length>0;){const l=Math.floor(Math.random()*s.length),i=s[l];s.splice(l,1);const o=`${i.row},${i.col}`;if(!r.has(o)&&(r.add(o),this.isValidFrontier(t,i))){const n={row:i.row-i.direction[0],col:i.col-i.direction[1]};n.dom=t.getCell(n.row,n.col).dom,i.dom=t.getCell(i.row,i.col).dom,this.animateMaze(t,[i,n]),L.forEach(a=>{const d={row:i.row+a[0]*2,col:i.col+a[1]*2,direction:a};s.push(d)})}}}kruskalMaze(t){const e=[];let r=1,s=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(0));for(let l=0;l<t.rows;l+=2)for(let i=0;i<t.cols;i+=2)i+_.HORIZONTAL[1]*2<t.cols&&e.push({row:l,col:i,direction:_.HORIZONTAL}),l+_.VERTICAL[0]*2<t.rows&&e.push({row:l,col:i,direction:_.VERTICAL}),s[l][i]=r,r++;for(;e.length>0;){const l=Math.floor(Math.random()*e.length),i=e[l],o={row:i.row+i.direction[0]*2,col:i.col+i.direction[1]*2};if(s[o.row][o.col]!==s[i.row][i.col]){const n=s[o.row][o.col],a=s[i.row][i.col];s=this.replaceFlag(s,n,a);const d=[];for(let M=i.row;M<=o.row;M++)for(let S=i.col;S<=o.col;S++){const R=t.getCell(M,S);d.push(R)}this.animateMaze(t,d)}e.splice(l,1)}}recursiveBacktrackingMaze(t){let e=t.getCell(0,0),r=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(!1));this.recursiveBacktrackingImpl(t,e,r)}recursiveBacktrackingImpl(t,e,r){r[e.row][e.col]=!0,this.animateMaze(t,[t.getCell(e.row,e.col)]);const s=L.map(l=>({row:e.row+l[0]*2,col:e.col+l[1]*2,direction:l})).filter(l=>t.valid_cell(l)&&!r[l.row][l.col]);for(;s.length>0;){const l=Math.floor(Math.random()*s.length),i=s[l];s.splice(l,1),!r[i.row][i.col]&&(this.animateMaze(t,[t.getCell(i.row-i.direction[0],i.col-i.direction[1])]),this.recursiveBacktrackingImpl(t,i,r))}}ellersMaze(t){let e=new Uint16Array(t.cols);for(let s=0;s<t.cols;s++)e[s]=s;let r=new Map;e.forEach(s=>{s%2!=1&&r.set(s,[s])});for(let s=0;s<t.rows;s+=2){let l=s+2>=t.rows;for(let o=0;o<t.cols-2;o+=2)e[o]!=e[o+2]&&(l||Math.floor(Math.random()*2))&&(this.mergeSetInRow(e,e[o],e[o+2],r),this.animateMaze(t,[t.getCell(s,o),t.getCell(s,o+1),t.getCell(s,o+2)]));if(l)continue;const i=new Uint16Array(t.cols);for(let o=0;o<t.cols;o++)i[o]=o+(s+2)*t.cols;r.forEach((o,n)=>{let a=Math.floor(Math.random()*o.length),d=o[a];i[d]=n,this.animateMaze(t,[t.getCell(s,d),t.getCell(s+1,d),t.getCell(s+2,d)])}),r=new Map,i.forEach((o,n)=>{if(n%2==1)return;const a=r.get(o);a?a.push(n):r.set(o,[n])}),e=i}}mergeSetInRow(t,e,r,s){s.set(e,[...s.get(e),...s.get(r)]),s.delete(r);for(let l=0;l<t.length;l+=2)t[l]==r&&(t[l]=e)}}const C=25,D=300;function O(){const c=window.innerWidth-D,t=window.innerHeight-D,e=Math.floor(c/C/2)*2+1;return{rows:Math.floor(t/C/2)*2+1,cols:e}}const{rows:F,cols:N}=O(),u=new y("board",F,N),z=new f;u.initializeElements();u.resetBoard();u.generateStartAndTarget();const W=document.getElementById("start-btn"),P=document.getElementById("reset-btn"),E=document.getElementById("algorithm-btn");z.initializeAlgorithmSelector(E);E.addEventListener("change",()=>{z.setAlgorithm(E.value)});P.addEventListener("click",()=>{u.resetBoard(),u.generateStartAndTarget()});W.addEventListener("click",()=>{u.clearBoard();const{visited_nodes:c,found_path:t}=z.findPath(u,u.start_cell,u.target_cell);u.visualizeVisitedNodes(c),u.visualizeFoundPath(t)});const I=new k,A=document.getElementById("maze-btn"),K=document.getElementById("generate-maze-btn");I.initializeMazeSelector(A);A.addEventListener("change",()=>{I.setAlgorithm(A.value)});K.addEventListener("click",()=>{I.generateMaze(u)});
