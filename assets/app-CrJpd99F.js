const p="wall";class k{constructor(t,e,r){this.board=document.getElementById(t),this.rows=e,this.cols=r,this.currentDelay=0,this.start_cell=null,this.target_cell=null,this.isMouseDown=!1,this.addWallEventListeners(),this.visitedNodes=[],this.foundPath=[]}initializeElements(){for(let t=0;t<this.rows;t++){let e=this.board.insertRow(t);for(let r=0;r<this.cols;r++)e.insertCell(r)}}resetDelayTime(){this.currentDelay=0}resetBoard(){this.clearBoard(),this.clearWalls(),this.resetDelayTime(),this.resetStartAndTarget()}clearBoard(){this.visitedNodes.forEach((t,e)=>{this.board.rows[t.row].cells[t.col].classList.remove("visitedNode")}),this.foundPath.forEach((t,e)=>{this.board.rows[t.row].cells[t.col].classList.remove("shortestPath")}),this.resetDelayTime()}fillWithWalls(){this.board.classList.add("fill-walls")}clearWalls(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++)this.board.rows[t].cells[e].classList.remove(p)}resetStartAndTarget(){this.start_cell!=null&&this.start_cell.dom.classList.remove("start-cell"),this.target_cell!=null&&this.target_cell.dom.classList.remove("target-cell"),this.start_cell=null,this.target_cell=null}visualizeVisitedNodes(t){t.forEach((e,r)=>{if(this.isStart(e)||this.isTarget(e))return;const s=this.board.rows[e.row].cells[e.col];setTimeout(()=>{s.className="visitedNode"},r*2+this.currentDelay)}),this.currentDelay+=t.length*2,this.visitedNodes=t}visualizeFoundPath(t){t.forEach((e,r)=>{if(this.isStart(e)||this.isTarget(e))return;const s=this.board.rows[e.row].cells[e.col];setTimeout(()=>{s.className="shortestPath"},r*5+this.currentDelay)}),this.currentDelay+=t.length*5,this.foundPath=t}valid_cell(t){return!(t.row<0||t.col<0||t.row>=this.rows||t.col>=this.cols)}getRandomCell(){let t=Math.floor(Math.random()*this.rows),e=Math.floor(Math.random()*this.cols);return{row:t,col:e}}getCell(t,e){return{dom:this.board.rows[t].cells[e],row:t,col:e}}generateStartAndTarget(){let t=null;do t=this.getRandomCell();while(this.isWall(this.getCell(t.row,t.col)));let e=null;do e=this.getRandomCell();while(e.row===t.row&&e.col===t.col||this.isWall(this.getCell(e.row,e.col)));this.setStartAndTarget(t,e)}setStartAndTarget(t,e){this.resetStartAndTarget(),this.start_cell=t,this.start_cell.dom=this.board.rows[t.row].cells[t.col],this.start_cell.dom.classList.add("start-cell"),this.target_cell=e,this.target_cell.dom=this.board.rows[e.row].cells[e.col],this.target_cell.dom.classList.add("target-cell")}addWallEventListeners(){this.board.addEventListener("dragstart",t=>t.preventDefault()),this.board.addEventListener("mousedown",t=>{t.preventDefault(),this.isMouseDown=!0,t.target.tagName==="TD"&&this.toggleWall(t.target)}),this.board.addEventListener("mouseover",t=>{this.isMouseDown&&t.target.tagName==="TD"&&this.toggleWall(t.target)}),window.addEventListener("mouseup",()=>{this.isMouseDown=!1})}resetToWalls(){this.clearBoard(),this.resetDelayTime(),this.resetStartAndTarget();const t=document.createDocumentFragment();for(let e=0;e<this.rows;e++){const r=document.createElement("tr");for(let s=0;s<this.cols;s++){const i=document.createElement("td");i.classList.add("wall"),r.appendChild(i)}t.appendChild(r)}this.board.innerHTML="",this.board.appendChild(t)}toggleWall(t){const e=t.parentNode.rowIndex,r=t.cellIndex;this.start_cell&&e===this.start_cell.row&&r===this.start_cell.col||this.target_cell&&e===this.target_cell.row&&r===this.target_cell.col||t.classList.add(p)}untoggleWall(t){t.classList.remove(p)}isWall(t){return this.board.rows[t.row].cells[t.col].classList.contains(p)}isTarget(t){return t.row===this.target_cell.row&&t.col===this.target_cell.col}isStart(t){return t.row===this.start_cell.row&&t.col===this.start_cell.col}}class T{constructor(){this.values=[]}enqueue(t,e){let r=!1;for(let s=0;s<this.values.length;s++)if(this.values[s].priority>e){this.values.splice(s,0,{node:t,priority:e}),r=!0;return}r||this.values.push({node:t,priority:e})}dequeue(){return this.values.shift()}size(){return this.values.length}}const g=(c,t,e)=>!t.valid_cell(c)||t.isWall(c)||e.find(r=>r.row===c.row&&r.col===c.col),v=(c,t)=>c.row===t.row&&c.col===t.col,B=(c,t)=>Math.abs(c.row-t.row)+Math.abs(c.col-t.col),f=Object.freeze({BFS:"BFS",DFS:"DFS",DIJIKSTRA:"Dijikstra",A_STAR:"A*"}),h=[[0,1],[1,0],[0,-1],[-1,0]];class w{constructor(){this.supported_algorithms=f,this.current_algorithm=f.BFS,this.selector_dom=null}initializeAlgorithmSelector(t){this.selector_dom=t;for(var[e,r]of Object.entries(this.supported_algorithms)){var s=document.createElement("option");s.value=r,s.innerHTML=r,t.appendChild(s)}t.value=this.current_algorithm}setAlgorithm(t){this.current_algorithm=t}findPath(t,e,r){switch(this.current_algorithm){case f.BFS:return w.BFS(t,e,r);case f.DFS:return w.DFS(t,e,r);case f.DIJIKSTRA:return w.Dijikstra(t,e,r);case f.A_STAR:return w.AStar(t,e,r);default:return console.log("Unsupported option ",this.current_algorithm),{visited_nodes:[],found_path:[]}}}static BFS(t,e,r){let s=[],i=[];for(i.push({...e,prev:[e]}),s.push(e);i.length>0;){const l=i.shift();for(let o=0;o<h.length;o++){const n={row:l.row+h[o][0],col:l.col+h[o][1]};if(g(n,t,s))continue;s.push(n);const a=[...l.prev,n];if(v(n,r))return{visited_nodes:s,found_path:a};i.push({...n,prev:a})}}return{visited_nodes:s,found_path:[]}}static DFS(t,e,r){let s=[];return w.DFSImpl(t,e,r,s)}static DFSImpl(t,e,r,s){if(s.push(e),v(e,r))return{visited_nodes:s,found_path:[e]};for(let i=0;i<h.length;i++){const l={row:e.row+h[i][0],col:e.col+h[i][1]};if(g(l,t,s))continue;const{found_path:o}=w.DFSImpl(t,l,r,s);if(o.length>0)return{visited_nodes:s,found_path:[e,...o]}}return{visited_nodes:s,found_path:[]}}static Dijikstra(t,e,r){let s=[],i=new T;for(i.enqueue({...e,path:[e]},0);i.size()>0;){const{node:l,priority:o}=i.dequeue();if(v(l,r))return{visited_nodes:s,found_path:l.path};if(!g(l,t,s)){s.push(l);for(let n=0;n<h.length;n++){const a={row:l.row+h[n][0],col:l.col+h[n][1]};g(a,t,s)||i.enqueue({...a,path:[...l.path,a]},o+1)}}}return{visited_nodes:s,found_path:[]}}static AStar(t,e,r){let s=[],i=new T;for(i.enqueue({...e,path:[e],distance:0,heuristic:0},0);i.size()>0;){const{node:l}=i.dequeue();if(v(l,r))return{visited_nodes:s,found_path:l.path};if(!g(l,t,s)){s.push(l);for(let o=0;o<h.length;o++){const n={row:l.row+h[o][0],col:l.col+h[o][1]};if(!g(n,t,s)){let a={...n,path:[...l.path,n],distance:l.distance+1,heuristic:B(n,r)};i.enqueue(a,a.distance+a.heuristic)}}}}return{visited_nodes:s,found_path:[]}}}const m={PRIM:"Prim",KRUSKAL:"Kruskal",RECURSIVE_BACKTRACKING:"Recursive Backtracking",ELLER:"Eller"},E=[[0,1],[1,0],[0,-1],[-1,0]],_={HORIZONTAL:[0,1],VERTICAL:[1,0]};Object.freeze(m);class y{constructor(){this.currentAlgorithm=m.PRIM}setAlgorithm(t){this.currentAlgorithm=t}generateMaze(t){switch(this.initializeMaze(t),this.currentAlgorithm){case m.PRIM:this.primMaze(t);break;case m.KRUSKAL:this.kruskalMaze(t);break;case m.RECURSIVE_BACKTRACKING:this.recursiveBacktrackingMaze(t);break;case m.ELLER:this.ellersMaze(t);break;default:console.error("Unknown maze generation algorithm");return}setTimeout(()=>{let e={row:0,col:0},r={row:t.rows-1,col:t.cols-1};t.setStartAndTarget(e,r)},this.currentDelay)}animateMaze(t,e){setTimeout(()=>{e.forEach(r=>{r.dom&&(r.dom.classList.add("maze-reveal"),t.untoggleWall(r.dom))})},this.currentDelay),this.currentDelay+=10}initializeMaze(t){this.currentDelay=0,t.resetToWalls()}isValidFrontier(t,e){return t.valid_cell(e)&&t.isWall(e)}replaceFlag(t,e,r){for(let s=0;s<t.length;s+=2)for(let i=0;i<t[s].length;i+=2)t[s][i]===e&&(t[s][i]=r);return t}initializeMazeSelector(t){const e=Object.values(m);t.innerHTML="",e.forEach(r=>{const s=document.createElement("option");s.value=r,s.text=`${r}'s Algorithm`,t.appendChild(s)})}primMaze(t){const e=t.getCell(0,0);this.animateMaze(t,[e]);const r=new Set;r.add(`${e.row},${e.col}`);const s=E.map(i=>({row:e.row+i[0]*2,col:e.col+i[1]*2,direction:i})).filter(i=>this.isValidFrontier(t,i,[]));for(;s.length>0;){const i=Math.floor(Math.random()*s.length),l=s[i];s.splice(i,1);const o=`${l.row},${l.col}`;if(!r.has(o)&&(r.add(o),this.isValidFrontier(t,l))){const n={row:l.row-l.direction[0],col:l.col-l.direction[1]};n.dom=t.getCell(n.row,n.col).dom,l.dom=t.getCell(l.row,l.col).dom,this.animateMaze(t,[l,n]),E.forEach(a=>{const d={row:l.row+a[0]*2,col:l.col+a[1]*2,direction:a};s.push(d)})}}}kruskalMaze(t){const e=[];let r=1,s=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(0));for(let i=0;i<t.rows;i+=2)for(let l=0;l<t.cols;l+=2)l+_.HORIZONTAL[1]*2<t.cols&&e.push({row:i,col:l,direction:_.HORIZONTAL}),i+_.VERTICAL[0]*2<t.rows&&e.push({row:i,col:l,direction:_.VERTICAL}),s[i][l]=r,r++;for(;e.length>0;){const i=Math.floor(Math.random()*e.length),l=e[i],o={row:l.row+l.direction[0]*2,col:l.col+l.direction[1]*2};if(s[o.row][o.col]!==s[l.row][l.col]){const n=s[o.row][o.col],a=s[l.row][l.col];s=this.replaceFlag(s,n,a);const d=[];for(let M=l.row;M<=o.row;M++)for(let S=l.col;S<=o.col;S++){const R=t.getCell(M,S);d.push(R)}this.animateMaze(t,d)}e.splice(i,1)}}recursiveBacktrackingMaze(t){let e=t.getCell(0,0),r=new Array(t.rows).fill(0).map(()=>new Array(t.cols).fill(!1));this.recursiveBacktrackingImpl(t,e,r)}recursiveBacktrackingImpl(t,e,r){r[e.row][e.col]=!0,this.animateMaze(t,[t.getCell(e.row,e.col)]);const s=E.map(i=>({row:e.row+i[0]*2,col:e.col+i[1]*2,direction:i})).filter(i=>t.valid_cell(i)&&!r[i.row][i.col]);for(;s.length>0;){const i=Math.floor(Math.random()*s.length),l=s[i];s.splice(i,1),!r[l.row][l.col]&&(this.animateMaze(t,[t.getCell(l.row-l.direction[0],l.col-l.direction[1])]),this.recursiveBacktrackingImpl(t,l,r))}}ellersMaze(t){let e=new Uint16Array(t.cols);for(let s=0;s<t.cols;s++)e[s]=s;let r=new Map;e.forEach(s=>{s%2!=1&&r.set(s,[s])});for(let s=0;s<t.rows;s+=2){let i=s+2>=t.rows;for(let o=0;o<t.cols-2;o+=2)e[o]!=e[o+2]&&(i||Math.floor(Math.random()*2))&&(this.mergeSetInRow(e,e[o],e[o+2],r),this.animateMaze(t,[t.getCell(s,o),t.getCell(s,o+1),t.getCell(s,o+2)]));if(i)continue;const l=new Uint16Array(t.cols);for(let o=0;o<t.cols;o++)l[o]=o+(s+2)*t.cols;r.forEach((o,n)=>{let a=Math.floor(Math.random()*o.length),d=o[a];l[d]=n,this.animateMaze(t,[t.getCell(s,d),t.getCell(s+1,d),t.getCell(s+2,d)])}),r=new Map,l.forEach((o,n)=>{if(n%2==1)return;const a=r.get(o);a?a.push(n):r.set(o,[n])}),e=l}}mergeSetInRow(t,e,r,s){s.set(e,[...s.get(e),...s.get(r)]),s.delete(r);for(let i=0;i<t.length;i+=2)t[i]==r&&(t[i]=e)}}const C=25,D=300;function F(){const c=window.innerWidth-D,t=window.innerHeight-D,e=Math.floor(c/C/2)*2+1;return{rows:Math.floor(t/C/2)*2+1,cols:e}}const{rows:W,cols:N}=F(),u=new k("board",W,N),z=new w;u.initializeElements();u.resetBoard();u.generateStartAndTarget();const O=document.getElementById("start-btn"),P=document.getElementById("reset-btn"),A=document.getElementById("algorithm-btn");z.initializeAlgorithmSelector(A);A.addEventListener("change",()=>{z.setAlgorithm(A.value)});P.addEventListener("click",()=>{u.resetBoard(),u.generateStartAndTarget()});O.addEventListener("click",()=>{u.clearBoard();const{visited_nodes:c,found_path:t}=z.findPath(u,u.start_cell,u.target_cell);u.visualizeVisitedNodes(c),u.visualizeFoundPath(t)});const I=new y,L=document.getElementById("maze-btn"),K=document.getElementById("generate-maze-btn");I.initializeMazeSelector(L);L.addEventListener("change",()=>{I.setAlgorithm(L.value)});K.addEventListener("click",()=>{I.generateMaze(u)});
